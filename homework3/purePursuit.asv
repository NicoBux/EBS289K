function [gamma, error] = purePursuit(q, L, Ld, path)

% Find nearest path point

% Converts path to robot coordinate frame
rTr = transl2(q(1),q(2))*trot2(q(3)); %Transformation from robot to world
rTr = inv(rTr); %Inverse is transformation from world to robot frame
path(:,3)=1; %Algebrae trick to allow the multiplication of matrices
P_robot = rTr*path'; %Final path in robot frame coordinates

%Find the number of points in Path
Points_number = length(path);

%Find index of point on path to calculate ey
previous = inf; index = 0;
di = zeros(1,Points_number);
distance = zeros(1,Points_number);

for k = 1:1:Points_number
    % path's x and y in robot frame
    x_robot = P_robot(1,k); y_robot = P_robot(2,k); 

    %find distance of robot(0,0)to points in path (in robot frame)
    di(k) = sqrt(x_robot^2+y_robot^2);
    distance(k) = abs(di(k) - Ld);
    dmin = min(di(di>0));
    
    if (x_robot > 0) && (di(k) < Ld) && (distance(k) <= previous) % check if point is in front of robot
        index = k; % this index represents the look ahead point
    end
    previous = distance(k);
end

%if no points is in front of robot, move to the closest point
if index == 0 
    ey = dmin;
else 
    ey = P_robot(2,index);
end
gamma = atan2(2*ey*L,Ld^2);

%cross track error, return the tracking error
error = dmin;


